//第一版 用的hashmap 效果不好 
需要注意的是 hashmap 的遍历方式是：五种方法见链接:https://blog.csdn.net/w605283073/article/details/80708943
// Iterating entries using a For Each loop
		for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
			System.out.println("Key = " + entry.getKey() + ", Value = " + entry.getValue());
		}
 
	}
执行结果：
通过
执行用时：
10 ms
, 在所有 Java 提交中击败了
16.84%
的用户
内存消耗：
40.1 MB
, 在所有 Java 提交中击败了
57.13%
的用户
class Solution {
    public int[] singleNumbers(int[] nums) {
    //输出：[1,6] 或 [6,1] 所以输出不需要有序
    Map<Integer, Integer> map = new HashMap<>();
    for(int i = 0; i < nums.length; i++){
        //可能需要建立两个map 哦 不需要 因为一个数最多出现两次 如果有 第二次之后就没有了
        if(map.containsKey(nums[i]))
            map.remove(nums[i]);
        else
            map.put(nums[i], 1);
        //map.getOrDefault(nums[i], -1) == -1?map.put(nums[i], 1):remove(nums[i]);
    }
    int[] ret = new int[2];
    int i = 0;
    for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
			ret[i] = entry.getKey();
            i++;
    }
    return ret;
    }
}

//第二版 K神 
链接：https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/solution/jian-zhi-offer-56-i-shu-zu-zhong-shu-zi-tykom/
class Solution {
    public int[] singleNumbers(int[] nums) {
        int x = 0, y = 0, n = 0, m = 1;
        for(int num : nums)               // 1. 遍历异或
            n ^= num;
        while((n & m) == 0)               // 2. 循环左移，计算 m
            m <<= 1;
        for(int num: nums) {              // 3. 遍历 nums 分组
            if((num & m) != 0) x ^= num;  // 4. 当 num & m != 0
            else y ^= num;                // 4. 当 num & m == 0
        }
        return new int[] {x, y};          // 5. 返回出现一次的数字
    }
}

//第三版 额外知识 通过异或可以“不使用第三个变量，交换两个变量的值”
a = 5
b = 1
现在不借助第三个值 交换a b的值
首先将a b表示为二进制
a = 0 0 0 1 = 1
b = 0 1 0 1 = 5
然后对a 异或b
a = 0 0 0 1
b = 0 1 0 1
———————————
a’= 0 1 0 0 
这个值覆盖a

然后对b 异或a’
b = 0 1 0 1
a’= 0 1 0 0
———————————
b’= 0 0 0 1 = 1 = a

然后对a’ 异或b’
a’= 0 1 0 0
b’= 0 0 0 1
———————————
a’’=0 1 0 1 = 5 = b

//第四版
不准备用异或 还是用56-II的方法结合56-I处理要找两个数的处理思想 看看效率如何
但是下面这个写法是错的，找区分两个数组的那个位，不能用下面A处的代码，因为会破坏数据nums[l]
改正后见第五版
class Solution {
    public int[] singleNumbers(int[] nums) {
        //不准备用异或 还是用56-II的方法结合56-I处理要找两个数的处理思想
        int[] sum = new int[32];
        for(int i = 0; i < nums.length; i++){
            for(int j = 0; j < 32; j++){
                sum[31 - j] += nums[i] & 1;
                nums[i] >>= 1;
            }
        }
        int k = 0;············································A
        for( ; k < 32; k++){
            if((sum[k] % 2) == 1){//29
                break;
            }
        }·····················································A
        int[] ret_a = new int[32];
        int[] ret_b = new int[32];
        for(int l = 0; l < nums.length; l++){
            if(nums[l]>>(31 - k) == 1){·······················A
                for(int i = 0; i < 32; i++){
                    ret_a[31 - i] = (ret_a[31 - i] + (nums[l] & 1)) % 2;
                    nums[l] >>= 1;               
                }
            }
            else{
                for(int j = 0; j < 32; j++){
                    ret_b[31 - j] =(ret_b[31 - j] + (nums[l] & 1)) % 2;
                    nums[l] >>= 1;               
                } 
            }         
        }
        int[] ret = new int[2];
        int a = 0;
        int b = 0;
        for(int i = 0; i < 32; i++){
            if(i == 31){
                a = a | ret_a[i];
                break;
            }  
            a = a | ret_a[i];
            a = a << 1;
        }
        for(int i = 0; i < 32; i++){
            if(i == 31){
                b = b | ret_b[i];
                break;
            }  
            b = b | ret_b[i];
            b = b << 1;
        }
        ret[0] = a;
        ret[1] = b;
        return ret_a;
    }
}
