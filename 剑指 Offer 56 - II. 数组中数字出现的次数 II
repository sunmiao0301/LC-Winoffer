//第一版 
用得hashmap 效果一般
执行结果：
通过
执行用时：
14 ms
, 在所有 Java 提交中击败了
48.82%
的用户
内存消耗：
39.3 MB
, 在所有 Java 提交中击败了
77.75%
的用户
class Solution {
    public int singleNumber(int[] nums) {
    /*
    本题没有限制空间复杂度
    我又想用hashmap了
     */
    HashMap<Integer, Integer> map = new HashMap<>();
    int get = 0;
    for(int i = 0; i < nums.length; i++){
        get = map.getOrDefault(nums[i], -1);
    if(get == -1)
        map.put(nums[i], 1);
    if(get == 1)
        map.replace(nums[i], 2);
    if(get == 2)
        map.remove(nums[i]);
    }
    for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
	    get =  entry.getKey();
    }
    return get;
    }
}

//K神 第二版 两种方法 链接：
https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/solution/mian-shi-ti-56-ii-shu-zu-zhong-shu-zi-chu-xian-d-4/
1）
遍历统计法（K神不推荐，表示没有有限状态自动机效果好，但是我觉得还不错）
时间复杂度 O(N)O(N) ： 其中 NN 位数组 numsnums 的长度；遍历数组占用 O(N)O(N) ，每轮中的常数个位运算操作占用 O(1)O(1) 。
空间复杂度 O(1)O(1) ： 数组 countscounts 长度恒为 3232 ，占用常数大小的额外空间。

根据K神思路我写出的结果(第一版：
但是有点问题
输入
[3,4,3,3]
[9,1,7,9,7,9,7]
输出
8
2
预期结果
4
1
class Solution {
    public int singleNumber(int[] nums) {
        int[] arr = new int[32];//全为0
        int ret = 0;
        //只有一个数 直接统计起来 % 3 即可
        for(int i = 0; i < nums.length; i++){
            for(int j = 0; j < arr.length; j++){
                arr[32 - j - 1] += nums[i] & 1;//第二轮取的时候这个nums[i] = 数组里面的 还是上面处理得到的？也就是说>> 和 ++ 一样还是和 +1 一样 （答：应该是和+1一样）
                nums[i] >>= 1;//右移
            }
        }
        for(int k = 0; k < arr.length; k++){
            arr[k] %= 3;
        }
        for(int l = 0; l < arr.length; l++){//已知二进制的各个位，转化为十进制？····················A
            ret = ret | arr[l];
            ret <<= 1;
        }
         ·························································································B
        return ret;
    }
}
于是我推算了一下
应该是由于多左移了一位 所以导致最后结果比正确结果左移了一位
于是我将A处代码改成for(int l = 0; l > arr.length - 1; l++)
结果变成输入
[3,4,3,3]
[9,1,7,9,7,9,7]
输出
4
0
预期结果
4
1
也就是说有一位没进去
所以说应该是32次，但是最后需要再右移一位即可，也就是：（如下C处代码所示）
class Solution {
    public int singleNumber(int[] nums) {
        int[] arr = new int[32];//全为0
        int ret = 0;
        //只有一个数 直接统计起来 % 3 即可
        for(int i = 0; i < nums.length; i++){
            for(int j = 0; j < arr.length; j++){
                arr[32 - j - 1] += nums[i] & 1;//第二轮取的时候这个nums[i] = 数组里面的 还是上面处理得到的？也就是说>> 和 ++ 一样还是和 +1 一样
                nums[i] >>= 1;//右移
            }
        }
        for(int k = 0; k < arr.length; k++){
            arr[k] %= 3;
        }
        for(int l = 0; l < arr.length; l++){//已知二进制的各个位，转化为十进制？
            ret = ret | arr[l];
            ret <<= 1;
        }
        ret >>= 1; ··········································C
        return ret;
    }

但是又不对：
执行结果：
解答错误
显示详情
添加备注
输入：
[1187668286,1703404529,608283674,80628156,470714103,545789803,1601734905,1049476153,827888143,1973694118,928077190,1017270134,1130834514,1505870015,492312433,1345819446,1117465717,438127490,146324924,1293329811,1135211376,1951741700,1383792482,575385216,999671282,1699186478,120574804,500246482,1107033800,1387873079,735873360,1580577809,34684910,1455126456,1725534527,234173687,2044903670,1537280240,1926673264,988014983,85941067,146214620,1574817800,1137362934,1854970684,132604030,209054985,81212589,1888731404,1755438182,1158494118,132505706,479534634,816528327,165682021,2130784595,1612495370,715683625,803639109,927612200,365637017,1008654192,1447285015,1334696286,1943228912,1075911415,1361281138,1527946625,1063585584,1307393649,653110960,945794718,1630397250,2092637600,990121939,617278901,839655332,977634702,1080947473,140663543,146479045,1057916799,1555106799,222671382,2113235337,384743188,1117275171,373613256,646525719,994899416,201859232,600335076,619769626,837244758,1456867613,11061
查看全部
输出：
-346649433
预期结果：
1800834215
想了一下
应该是和我的处理顺序有关，我在C处的修改是
先多左移了一位，然后退出之后再回退一位，但是回退的那一位是无符号回退，无论如何都是0，如果出去的那一位是1，这样实际上是会丢失信息的，
所以应该在里面的最后一次就不回退，
也就是如下D处代码所示：
结果成功：
执行结果：
通过
执行用时：
7 ms
, 在所有 Java 提交中击败了
65.35%
的用户
内存消耗：
39.4 MB
, 在所有 Java 提交中击败了
52.35%
的用户
但是还是不够好，其实 % 3 可以和最后计算出 ret 放到一起的
见K神方法二
class Solution {
    public int singleNumber(int[] nums) {
        int[] arr = new int[32];//全为0
        int ret = 0;
        //只有一个数 直接统计起来 % 3 即可
        for(int i = 0; i < nums.length; i++){
            for(int j = 0; j < arr.length; j++){
                arr[32 - j - 1] += nums[i] & 1;//第二轮取的时候这个nums[i] = 数组里面的 还是上面处理得到的？也就是说>> 和 ++ 一样还是和 +1 一样
                nums[i] >>= 1;//右移
            }
        }
        for(int k = 0; k < arr.length; k++){
            arr[k] %= 3;
        }
        for(int l = 0; l < arr.length; l++){//已知二进制的各个位，转化为十进制？
            ret = ret | arr[l];
            if(l < arr.length - 1)·························D
                ret <<= 1;·································D
        }
        return ret;
    }
}

//K神
方法一）有限状态自动机
时间复杂度 O(N)O(N) ： 其中 NN 位数组 numsnums 的长度；遍历数组占用 O(N)O(N) ，每轮中的常数个位运算操作占用 O(32 \times3 \times 2) = O(1)O(32×3×2)=O(1) 。
空间复杂度 O(1)O(1) ： 变量 onesones , twostwos 使用常数大小的额外空间
class Solution {
    public int singleNumber(int[] nums) {
        int ones = 0, twos = 0;
        for(int num : nums){
            ones = ones ^ num & ~twos;
            twos = twos ^ num & ~ones;
        }
        return ones;
    }
}


方法二）遍历统计
时间复杂度 O(N)O(N) ： 其中 NN 位数组 numsnums 的长度；遍历数组占用 O(N)O(N) ，每轮中的常数个位运算操作占用 O(1)O(1) 。
空间复杂度 O(1)O(1) ： 数组 countscounts 长度恒为 3232 ，占用常数大小的额外空间
执行结果：
通过
执行用时：
4 ms
, 在所有 Java 提交中击败了
                         86.59%
的用户
内存消耗：
38.8 MB
, 在所有 Java 提交中击败了
                         99.45%
的用户
class Solution {
    public int singleNumber(int[] nums) {
        int[] counts = new int[32];
        for(int num : nums) {
            for(int j = 0; j < 32; j++) {
                counts[j] += num & 1;
                num >>>= 1;
            }
        }
        int res = 0, m = 3;
        for(int i = 0; i < 32; i++) {
            res <<= 1;
            res |= counts[31 - i] % m;
        }
        return res;
    }
}

PS：实际上，只需要修改求余数值 mm ，即可实现解决 除了一个数字以外，其余数字都出现 mm 次 的通用问题
实际上，只需要修改求余数值 mm ，即可实现解决 除了一个数字以外，其余数字都出现 mm 次 的通用问题
实际上，只需要修改求余数值 mm ，即可实现解决 除了一个数字以外，其余数字都出现 mm 次 的通用问题
实际上，只需要修改求余数值 mm ，即可实现解决 除了一个数字以外，其余数字都出现 mm 次 的通用问题
实际上，只需要修改求余数值 mm ，即可实现解决 除了一个数字以外，其余数字都出现 mm 次 的通用问题
实际上，只需要修改求余数值 mm ，即可实现解决 除了一个数字以外，其余数字都出现 mm 次 的通用问题
