//第一版
class Solution {
    public int nthUglyNumber(int n) {
    /*
    “只包含质因子 2 3 5 是什么意思”
    偷看了一眼题解
    大概是动态规划解决 通过
    1 2 3 5
    构造dp[]
    1 2 3
    4 5 6 8 10 12 15 16 18 20 
    思路应该是
    求dp[i]时
    通过前面的值 乘以2 3 5 得到与当前dp[i-1]最相近的值
    但是如何构造算法是个问题
    观察丑数数列 我突然发现
    6 = 2 3

    8 = 2 4
    10 = 2 5
    12 = 2 6
    15 = 3 5
    16 = 4 4
    18 = 
    看来找规律是行不通的 于是又偷瞟了一眼 原来和我之前的思路一样
    通过乘以2 3 5(一个丑数通过另一个丑数 * 2 3 5得到)
    */
    int dp1 = 1;
    int dp2 = 2;
    int dp3 = 3;
    int flag = 3;
    for(int i = 3; i < n; i++){
        /*
        dp1 * 2
        dp1 * 3 dp2 * 2
        dp1 * 5 dp2 * 2
        dp1 * 5 dp2 * 3  
        dp2 * 5
        dp3 * 2
        但是K神提出：
        根根据递推性质，丑数 x_{n+1}x n+1
        只可能是以下三种情况其中之一（索引 a, b, ca,b,c 为未知数）：
        */
        if(dp1 * 2 > dp3){
            dp1 *= 2;
            swap(dp1, dp3);//始终保证dp1 < dp2 < dp3
            continue;
        }
        if(dp1 * 5 > dp2 * 2)
        if(dp2 * 2 > dp3){//dp1 * 3
            dp2 *= 2;
            swap(dp2, dp3);
            continue;
        }
        if(dp)
    }
    }
    void swap(int a, int b){
        int temp = a;
        a = b;
        b = temp;
    }
}
·······················································
写到这里的时候
我突然发现
由于初始值dp[1] dp[2] dp[3] 没有选取好
导致后面也都不好 思路也乱
其实应该是三指针 大数组
