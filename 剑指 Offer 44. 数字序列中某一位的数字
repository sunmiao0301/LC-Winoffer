//第一版 没有处理好奇数偶数在int强制类型转换下的差别
38 / 70 个通过测试用例
状态：解答错误
提交时间：19 分钟前
最后执行的输入：
10
也就是偶数时出错
class Solution {
    public int findNthDigit(int n) {
    /*
    隐隐感觉是递归解决
    从下标0开始计数！
    123456789(9 = 10 - 1)
    10111213141516171819
    20
    ···
    90919293949596979899(91 = 100 - 9)
    100101102103104105106107108109
    111
    ···999
    （1000 - 100 - 9 = 891）
    位数 * 数量
    1 * 9 对 1 取余为 0 被 1 整除得到的商就是要求的值
    2 * （100 - 9）      减去 9 后，对 2 取余。为 0 则是个位数 为1 则是十位数；整除得到的商则是
    3 * （1000 -100 - 9）减去1 * 9 + 2 * 90 个后，对3取余。为0 则为个位数 为1 则是十位数 为2 则是百位数
    4 * （）             减去1 * 9 + 2 * 90 + 3 * 900
    我知道思路了
    通过余数可以确定是哪一数位
    通过整除可以确定是第几个数（注意：不是第几位）
    */
    int old = 0;
    int new_new = 9 * 1;
    int old_num = 0;
    for(int i = 1; i < 20; i++){
        if(n > old && n <= new_new){//此时 i + 1 是位数
            n = n - old;
            int which_bit = n % i;
            int which_num = n / i + old_num;
            for(int j = 0; j < which_bit; j++){
                which_num = n / (i + 1) + old_num;
            }
            which_num %= 10;
            
            return which_num;
        }
        old = new_new;
        new_new += (i + 1) * 9 * (int)Math.pow(10, i);
        old_num += 9 * (int)Math.pow(10, i - 1);
    }
    return -1;
    }
}

//第二版 改正之后上面因为int发生的错误后
53 / 70 个通过测试用例
状态：解答错误
提交时间：几秒前
最后执行的输入：
10000
然后我都检查了一下 在100 1000 10000···时都不对
class Solution {
    public int findNthDigit(int n) {
    /*
    隐隐感觉是递归解决
    从下标0开始计数！
    123456789(9 = 10 - 1)
    10111213141516171819
    20
    ···
    90919293949596979899(91 = 100 - 9)
    100101102103104105106107108109
    111
    ···999
    （1000 - 100 - 9 = 891）
    位数 * 数量
    1 * 9 对 1 取余为 0 被 1 整除得到的商就是要求的值
    2 * （100 - 9）      减去 9 后，对 2 取余。为 0 则是个位数 为1 则是十位数；整除得到的商则是
    3 * （1000 -100 - 9）减去1 * 9 + 2 * 90 个后，对3取余。为0 则为个位数 为1 则是十位数 为2 则是百位数
    4 * （）             减去1 * 9 + 2 * 90 + 3 * 900
    我知道思路了
    通过余数可以确定是哪一数位
    通过整除可以确定是第几个数（注意：不是第几位）
    */
    int old = 0;
    int new_new = 9 * 1;
    int old_num = 0;
    for(int i = 1; i < 20; i++){
        if(n > old && n <= new_new){//此时 i + 1 是位数
            n = n - old;
            int which_bit = n % i;
            int which_num = 0;//
            if(n % i != 0)
                which_num = n / i + old_num + 1;
            else
                which_num = n / i + old_num;
            for(int j = 0; j < which_bit; j++){
                which_num /= (int)Math.pow(10, i - 1);
            }
            which_num %= 10;
            
            return which_num;
        }
        old = new_new;
        new_new += (i + 1) * 9 * (int)Math.pow(10, i);
        old_num += 9 * (int)Math.pow(10, i - 1);
    }
    return -1;
    }
}
