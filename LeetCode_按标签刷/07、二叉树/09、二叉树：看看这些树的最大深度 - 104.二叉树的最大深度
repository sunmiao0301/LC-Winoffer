//第一版 用的是层序遍历 统计层数 虽然通过 但是时间复杂度很差
执行结果：
通过
执行用时：
1 ms
, 在所有 Java 提交中击败了
19.00%
的用户
内存消耗：
38.3 MB
, 在所有 Java 提交中击败了
64.43%
的用户
通过测试用例：
39 / 39
class Solution {
    //感觉只有层序遍历才行？
    public int maxDepth(TreeNode root) {
        int depth = 0;//第一层是1
        Queue<TreeNode> queue = new LinkedList<>();
        if(root == null) return depth;
        queue.offer(root);
        depth++;
        while(!queue.isEmpty()){
            int size = queue.size();
            while(size > 0){
                TreeNode temp = queue.poll();
                if(temp.left != null)
                    queue.offer(temp.left);
                if(temp.right != null)
                    queue.offer(temp.right);
                size--;
            }
            depth++;
        }
        return depth - 1;//queue.isEmpty()的时候 还会执行一次depth++
    }
}

//第二版 一遍过 换成递归 时间复杂度好多了
执行结果：
通过
执行用时：
0 ms
, 在所有 Java 提交中击败了
100.00%
的用户
内存消耗：
38.3 MB
, 在所有 Java 提交中击败了
55.65%
的用户
通过测试用例：
39 / 39
class Solution {
    int depth = 0;
    public int maxDepth(TreeNode root) {
        if(root == null) return depth;
        helper(root, 1);
        return depth;
    }
    void helper(TreeNode root, int d){
        if(d > depth) depth = d;
        if(root.left != null)
            helper(root.left, d + 1);
        if(root.right != null)
            helper(root.right, d + 1);
        return;
    }
}
