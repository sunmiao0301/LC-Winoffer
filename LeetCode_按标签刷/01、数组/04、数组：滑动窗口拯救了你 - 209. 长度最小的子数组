//第一版 写到深夜 效率一般
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
    /*
    长度最小的
    滑动窗口还是不熟练
    我好像想到只遍历一遍的方法了
    之前剑指offer中提到过滑动窗口实际上是等价于双端队列的
    */
    if(nums[0] >= target)return 1;
    Deque<Integer> Deque = new LinkedList<>();
    int sum = 0, i = 0;
    for(i = 0; i < nums.length; i++){
        Deque.addLast(nums[i]);
        sum += nums[i];
        if(sum >= target)
            break;
    }
    if(i == nums.length)//说明直到最后一个值 都不够target
        return 0;

    if(i == nums.length - 1){//说明最后一个值加上之后大于等于target
        while(!Deque.isEmpty() && sum >= target){
            sum -= Deque.pollFirst();
        }
        return Deque.size() + 1;
    }
    int min = Deque.size();
    while(i < nums.length - 1 && !Deque.isEmpty()){
        if(sum >= target){
            sum -= Deque.pollFirst();
            if(Deque.size() < min && sum >= target)
                min = Deque.size();
            //min = (Deque.size() < min && sum >= target) ? Deque.size() : min;
            continue;
        }
        else{
            sum -= Deque.pollFirst();
            //min = (Deque.size() < min && sum >= target) ? Deque.size() : min;
            i++;
            Deque.addLast(nums[i]);
            sum += nums[i];
            
            if(Deque.size() < min && sum >= target)
                min = Deque.size();
            //min = (Deque.size() < min && sum >= target) ? Deque.size() : min;
            continue;
        }
    }
    if(Deque.isEmpty())
        return 1;
    return min;
    }
}
/*
213
[12,28,83,4,25,26,25,2,25,25,25,12]
80
[10,5,13,4,8,4,5,11,14,9...,16,10,20,8]
4
[1,4,4]
15
[1,2,3,4,5]
11
[1,2,3,4,5]
213
[12,28,83,4,25,26,25,2,25,25,25,12]
7
[2,3,1,2,4,3]
80
[10,5,13,4,8,4,5,11,14,9,16,10,20,8]
80
[11,14,9,16,10,20,8]
80
[4,5,11,14,9,16,10,20,8]
*/

//第二版 
就是想不要优化第一版速度的办法 
下面直接挂标准题解：
其实题解的思路与我的差别不大，关键在于
1）在更新min的时候 由于用的是双指针 所以节省了大量时间？把我用的Deque.size()修改成了双指针的hi - lo（没有用Deque）

············那么，是否滑动窗口问题都可以用双指针 而不必用 Deque 呢

class Solution {    
    public int minSubArrayLen(int target, int[] nums) {
        int lo = 0, hi = 0, sum = 0, min = Integer.MAX_VALUE;
        while (hi < nums.length) {
            sum += nums[hi++];
            while (sum >= target) {
                min = Math.min(min, hi - lo);
                sum -= nums[lo++];
            }
        }
        return min == Integer.MAX_VALUE ? 0 : min;
    }
}
