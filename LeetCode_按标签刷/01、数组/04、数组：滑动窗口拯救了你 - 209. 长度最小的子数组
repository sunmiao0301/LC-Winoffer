//第一版 写到深夜 效率一般
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
    /*
    长度最小的
    滑动窗口还是不熟练
    我好像想到只遍历一遍的方法了
    之前剑指offer中提到过滑动窗口实际上是等价于双端队列的
    */
    if(nums[0] >= target)return 1;
    Deque<Integer> Deque = new LinkedList<>();
    int sum = 0, i = 0;
    for(i = 0; i < nums.length; i++){
        Deque.addLast(nums[i]);
        sum += nums[i];
        if(sum >= target)
            break;
    }
    if(i == nums.length)//说明直到最后一个值 都不够target
        return 0;

    if(i == nums.length - 1){//说明最后一个值加上之后大于等于target
        while(!Deque.isEmpty() && sum >= target){
            sum -= Deque.pollFirst();
        }
        return Deque.size() + 1;
    }
    int min = Deque.size();
    while(i < nums.length - 1 && !Deque.isEmpty()){
        if(sum >= target){
            sum -= Deque.pollFirst();
            if(Deque.size() < min && sum >= target)
                min = Deque.size();
            //min = (Deque.size() < min && sum >= target) ? Deque.size() : min;
            continue;
        }
        else{
            sum -= Deque.pollFirst();
            //min = (Deque.size() < min && sum >= target) ? Deque.size() : min;
            i++;
            Deque.addLast(nums[i]);
            sum += nums[i];
            
            if(Deque.size() < min && sum >= target)
                min = Deque.size();
            //min = (Deque.size() < min && sum >= target) ? Deque.size() : min;
            continue;
        }
    }
    if(Deque.isEmpty())
        return 1;
    return min;
    }
}
/*
213
[12,28,83,4,25,26,25,2,25,25,25,12]
80
[10,5,13,4,8,4,5,11,14,9...,16,10,20,8]
4
[1,4,4]
15
[1,2,3,4,5]
11
[1,2,3,4,5]
213
[12,28,83,4,25,26,25,2,25,25,25,12]
7
[2,3,1,2,4,3]
80
[10,5,13,4,8,4,5,11,14,9,16,10,20,8]
80
[11,14,9,16,10,20,8]
80
[4,5,11,14,9,16,10,20,8]
*/

//
