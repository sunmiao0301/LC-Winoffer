//第一版 这种简单的问题靠一直运行和改动来得到正确答案意义不大 以后应该尽量一次成功
//且第一版的方法是暴力 应该用二分
class Solution {
    public int minArray(int[] numbers) {
    //“输入一个递增排序的数组的一个旋转”
    int ret = numbers[0];
    for(int i = 1; i < numbers.length; i++){
        if(numbers[i-1] > numbers[i]){
            ret = numbers[i];
            break;
        }
    }
    return ret;
    }
}

//用二分法 但是二分法处理这种问题就是要注意各种情况全面考虑 没推出来 有点不在状态
class Solution {
    public int minArray(int[] numbers) {
        int low = 0;
        int high = numbers.length - 1;
        while (low < high) {
            int pivot = low + (high - low) / 2;
            if (numbers[pivot] < numbers[high]) {
                high = pivot;
            } else if (numbers[pivot] > numbers[high]) {
                low = pivot + 1;
            } else {
                high -= 1;
            }
        }
        return numbers[low];
    }
}


//第三版 一步步来 第三版先解决数组中没有重复数字时的情况 这一步还是不对 
class Solution {
    public int minArray(int[] numbers) {
    //各种情况 可以从简到繁 一步步迭代
    //实际上这题就是一个给定排布情况的数组（不是一般的递增数组）让你找出其中的最小值
    /*
    首先考虑没有重复数字时候的情况 也就是
                        *
                    *
                *
            *
        *
    *
    变成
            *
        *
    *
                        *
                    *
                *    
    1)此时，如果finder处的值大于low的值 则此时finder处于未旋转的部分数组
    则可知finder左边的都不是我们要找的值 直接把low变成finder
    2)此时，如果finder处的值小于high的值 则此时finder     必然    处于旋转的那部分数组
    则可知finder右边的都不是我们要找的值
    */ 
        int low = 0;
        int high = numbers.length - 1;
        while(low < high){
            int finder = low + (high - low) / 2;
            if(numbers[finder] > numbers[low])
                low = finder;
            else if(numbers[finder] < numbers[high])
                high = finder;
        }
    return numbers[high-1];
    }
}

//第四版 因为进入while里面先对high进行处理和先对low处理的结果是不一样的 第三版的处理方法会出错
class Solution {
    public int minArray(int[] numbers) {
        int low = 0;
        int high = numbers.length - 1;
        while(low < high){
            int finder = low + (high - low) / 2;
            //这里先对high进行处理和先对low处理的结果是不一样的
            if(numbers[finder] < numbers[high])
                high = finder;
            else if( numbers[low] < numbers[finder])
                low = finder;
        }
    return numbers[high];
    }
}

/*
第五版 第四版还是不行 因为会卡死
如样例是[7,8,9,1,3,5]时，就会卡在low = 2 high = 3 
到下一轮的时候，finder = 2，第一个if走不出去，第二个if也走不出去
思考一下 low最大也是比待找的那个点小1
high最小的话应该是可以刚好在要找的那个点
所以要改的话就应该对low，也就是low = finder + 1;
*/
class Solution {
    public int minArray(int[] numbers) {
        int low = 0;
        int high = numbers.length - 1;
        while(low < high){
            int finder = low + (high - low) / 2;
            //这里先对high进行处理和先对low处理的结果是不一样的
            if(numbers[finder] < numbers[high])
                high = finder;
            else if(numbers[finder] > numbers[low])
                low = finder + 1;//修改
        }
    return numbers[high];
    }
}

//第六版 接下来就是要解决重复数字的问题
//首先 我们检验一下在有重复数字的情况下 之前两个if elseif 是否还对
//再加个循环 既然还是else if
那么必然不满足之前两个条件
