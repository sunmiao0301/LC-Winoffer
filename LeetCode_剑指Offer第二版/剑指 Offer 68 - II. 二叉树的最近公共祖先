//第一版
15 / 31 个通过测试用例
状态：解答错误
提交时间：几秒前
最后执行的输入：
[1,2,3,null,4]
4
1
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    /*
    这次是二叉树 不是搜索二叉树了
    所有节点的值都是唯一的。
    p、q 为不同节点且均存在于给定的二叉树中。
    猜测是递归回溯
    实际上不用回溯 直接DFS即可
    分析一下：
    对于任何一个当前root值 都进行如下递归
    1）如果左边有，右边有，就返回root
    2）如果左边无，右边有，就进入左边找，如果左边有，就返回root，如果左边无，就返回root.right
    3）如果右边无，左边有，就进入右边找，如果右边有，就返回root，如果右边无，就返回root.left
    4）如果左右都无，就继续进入左右
    5）如果到了叶子都无，就返回null
    */
    if(root.left == null && root.right == null)return null;
    else if(root.left == null && root.right != null){
        if(root.right.val != p.val && root.right.val != q.val)
            return lowestCommonAncestor(root.right, p, q);
        return root;
    }
    else if(root.left != null && root.right == null){
        if(root.left.val != p.val && root.left.val != q.val)
            return lowestCommonAncestor(root.left, p, q);
        return root;
    }
    else if((root.left.val == p.val && root.right.val == q.val) || (root.left.val == q.val && root.right.val ==p.val))return root;
    //所有节点的值都是唯一的。
    else if((root.left.val == p.val || root.left.val == q.val)){
        if((lowestCommonAncestor(root.right, p, q)) != null)return root;
        return root.left;
    }
    else if((root.right.val == p.val || root.left.val == q.val)){
        if((lowestCommonAncestor(root.left, p, q)) != null)return root;
        return root.right;
    }
    if(lowestCommonAncestor(root.left, p, q) != null)
        return lowestCommonAncestor(root.left, p, q);
    return lowestCommonAncestor(root.right, p, q);
    }
}

//第二版
老是卡在此处：
输入
[1,2,3,null,4]
4
3
输出
3
预期结果
1
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root.val == p.val || root.val == q.val)return root;
        else if(isExist(root.left, p, q) && isExist(root.right, p, q))return root;
        else if(isExist(root.left, p, q)){
            if(root.left.val == p.val || root.left.val == q.val)return root.left;
        return lowestCommonAncestor(root.left, p, q);
        }
        else if(isExist(root.right, p, q)){
            if(root.right.val == p.val || root.right.val == q.val)return root.right;
        return lowestCommonAncestor(root.right, p, q);
        }
        return new TreeNode(0);
    }
    boolean isExist(TreeNode root, TreeNode p, TreeNode q){//分析包括root在内的下面的节点是否含有p或q
    if(root.left != null)
        isExist(root.left, p, q);
    if(root.val == p.val || root.val == q.val)return true;
    if(root.right != null)
        isExist(root.right, p, q);
    return false;
    }
}
