//第一版 暴力法 子数组长度作为外围循环 数组索引作为内部循环
程序运行统计的子数组大小 变化 是：
1 1 1 1 1··········2 2 2 2··········3 3 3········
卡在199/202个测试样例处
执行结果：
超出时间限制
最后执行的输入：
[-57,9,-72,-72,-62,45,-97,24,-39,35,-82,-4,-63,1,-93,42,44,1,-75,-25,-87,-16,9,-59,20,5,-95,-41,4,-30,47,46,78,52,74,93,-3,53,17,34,-34,34,-69,-21,-87,-86,-79,56,-9,-55,-69,3,5,16,21,-75,-79,2,-39,25,72,84,-52,27,36,98,20,-90,52,-85,44,94,25,51,-27,37,41,-6,-30,-68,15,-23,11,-79,93,-68,-78,90,11,-41,-8,-17,-56,17,86,56,15,7,66,-56,-2,-13,-62,-77,-62,-12,37,55,81,-93,86,-27,-39,-3,-30,-46,6,-8,-79,-83,50,-10,-24,70,-93,-38,27,-2,45,-7,42,-57,79,56,-57,93,-56,79,48,-98,62,11,-48,-77,84,21,-47,-10,-87,-49,-17,40,40,35,10,23,97,-63,-79,19,6,39,62,-38,-27,81,-68,-7,60,79,-28,-1,-33,23,22,-48,-79,51,18,-66,-98,-98,50,41,13,-63,-59,10,-49,-38,-70,56,77,68,95,-73,26,-73,20,-14,83,91,61,-50,-9,-40,1,11,-88,-80,21,89,97,-29,8,10,-15,48,97,35,86,-96,-9,64,48,-37,90,-26,-10,-13,36,-27,-45,-3,-1,45,34,77,-66,22,73,54,11,70,-97,-81,-43,-13,44,-69,-78,30,-66,-11,-29,58,52,-61,-68,-81,25,44,-32,57,-81,66,2,52,43,35,-26,16,-33,61,-37,-54,80,-3,32,24,27,30,-69,38,-81,2,-4,47,17,5,42,-58,-51,-90,98,-33,7

class Solution {
    public int maxSubArray(int[] nums) {
    /*
    简单分析一下 发现这题没有想象的简单
    比如多个同样的数字 放入哪个子数组 得到的“所有子数组的和的最大值”最大
    比如对于···
    先试试暴力 然后由简入繁
    对于题目所给的示例 答案应该是
    -5
    -3 -2 -1
    1 2
    1
    4
    为什么答案的解释“解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。”中不含-5？
    原来这个连续子数组 指的是 在数组中的位置连续 而不是数值上连续
    所以可以暴力

    */
    int max = nums[0];
    for(int length = 1; length <= nums.length; length++){
        for(int i = -1; i < nums.length - 1; i++){
            if(i + length < nums.length)
                max = sum(length, i, nums) > max ? sum(length, i, nums) : max;
        }
    }
    return max;
    }
    int sum(int length, int i, int[] nums){
        int ret = 0;
        while(length > 0){
            ret = ret + nums[i + length];
            length--;
        }
        return ret;
    }
}

//第二版  第二种暴力 窗口值大小作为外围循环 数组索引作为内部循环
只不过减少了一点重复的加法运算
子数组大小变化 是：
1 1 1 1 1·········2 2 2 2···········3 3 3···········
运行结果与第一版相同
执行结果：
超出时间限制
最后执行的输入：
[-57,9,-72,-72,-62,45,-97,24,-39,35,-82,-4,-63,1,-93,42,44,1,-75,-25,-87,-16,9,-59,20,5,-95,-41,4,-30,47,46,78,52,74,93,-3,53,17,34,-34,34,-69,-21,-87,-86,-79,56,-9,-55,-69,3,5,16,21,-75,-79,2,-39,25,72,84,-52,27,36,98,20,-90,52,-85,44,94,25,51,-27,37,41,-6,-30,-68,15,-23,11,-79,93,-68,-78,90,11,-41,-8,-17,-56,17,86,56,15,7,66,-56,-2,-13,-62,-77,-62,-12,37,55,81,-93,86,-27,-39,-3,-30,-46,6,-8,-79,-83,50,-10,-24,70,-93,-38,27,-2,45,-7,42,-57,79,56,-57,93,-56,79,48,-98,62,11,-48,-77,84,21,-47,-10,-87,-49,-17,40,40,35,10,23,97,-63,-79,19,6,39,62,-38,-27,81,-68,-7,60,79,-28,-1,-33,23,22,-48,-79,51,18,-66,-98,-98,50,41,13,-63,-59,10,-49,-38,-70,56,77,68,95,-73,26,-73,20,-14,83,91,61,-50,-9,-40,1,11,-88,-80,21,89,97,-29,8,10,-15,48,97,35,86,-96,-9,64,48,-37,90,-26,-10,-13,36,-27,-45,-3,-1,45,34,77,-66,22,73,54,11,70,-97,-81,-43,-13,44,-69,-78,30,-66,-11,-29,58,52,-61,-68,-81,25,44,-32,57,-81,66,2,52,43,35,-26,16,-33,61,-37,-54,80,-3,32,24,27,30,-69,38,-81,2,-4,47,17,5,42,-58,-51,-90,98,-33,7

class Solution {
    public int maxSubArray(int[] nums) {
    int max = nums[0];
    for(int window = 1; window <= nums.length; window++){
        int window_val = sum(window, nums);
        if(window_val > max)
            max = window_val;
        for(int i = 0; i < nums.length - 1; i++){
            if(i + window < nums.length){
                window_val = window_val - nums[i] + nums[i + window];
                if(window_val > max)
                    max = window_val;
            }
        }
    }
    return max;
    }
    int sum(int window, int[] nums){
        int ret = 0;
        for(int i = 0; i < window; i++){
            ret = ret + nums[i];
        }
        return ret;
    }
}

//第三版 时间复杂是o（n2）的思路
这一版思路中 依次得到的子数组大小：
1 2 3 4 5·······1 2 3 4·······1 2 3···········
比第一轮第二轮的o（n3）减少了时间复杂度 但是仍旧没有达到题目要求的o（n）
执行结果：
超出时间限制
最后执行的输入：
[-57,9,-72,-72,-62,45,-97,24,-39,35,-82,-4,-63,1,-93,42,44,1,-75,-25,-87,-16,9,-59,20,5,-95,-41,4,-30,47,46,78,52,74,93,-3,53,17,34,-34,34,-69,-21,-87,-86,-79,56,-9,-55,-69,3,5,16,21,-75,-79,2,-39,25,72,84,-52,27,36,98,20,-90,52,-85,44,94,25,51,-27,37,41,-6,-30,-68,15,-23,11,-79,93,-68,-78,90,11,-41,-8,-17,-56,17,86,56,15,7,66,-56,-2,-13,-62,-77,-62,-12,37,55,81,-93,86,-27,-39,-3,-30,-46,6,-8,-79,-83,50,-10,-24,70,-93,-38,27,-2,45,-7,42,-57,79,56,-57,93,-56,79,48,-98,62,11,-48,-77,84,21,-47,-10,-87,-49,-17,40,40,35,10,23,97,-63,-79,19,6,39,62,-38,-27,81,-68,-7,60,79,-28,-1,-33,23,22,-48,-79,51,18,-66,-98,-98,50,41,13,-63,-59,10,-49,-38,-70,56,77,68,95,-73,26,-73,20,-14,83,91,61,-50,-9,-40,1,11,-88,-80,21,89,97,-29,8,10,-15,48,97,35,86,-96,-9,64,48,-37,90,-26,-10,-13,36,-27,-45,-3,-1,45,34,77,-66,22,73,54,11,70,-97,-81,-43,-13,44,-69,-78,30,-66,-11,-29,58,52,-61,-68,-81,25,44,-32,57,-81,66,2,52,43,35,-26,16,-33,61,-37,-54,80,-3,32,24,27,30,-69,38,-81,2,-4,47,17,5,42,-58,-51,-90,98,-33,7
class Solution {
    public int maxSubArray(int[] nums) {
        int max = nums[0];
        for(int index = 0; index < nums.length; index++){
            int sum = 0;
            for(int i = index; i < nums.length; i++){
                sum += nums[i];
                if(sum > max)
                    max = sum;
            }
        }
    return max;
    }
}

//第四版 还有K神提到的复杂度为 ：分治思想	O(NlogN)时间	O(logN)空间

//第五版 动态规划 看完题解自己写的版本
执行结果：
通过
执行用时：
1 ms
, 在所有 Java 提交中击败了
98.64%
的用户
内存消耗：
44.7 MB
, 在所有 Java 提交中击败了
83.25%
的用户
讲解的最好的题解就是：
https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/solution/cong-bao-li-po-jie-dao-dong-tai-gui-hua-yfvkp/
图示最好的题解是：
https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/solution/mian-shi-ti-42-lian-xu-zi-shu-zu-de-zui-da-he-do-2/
class Solution {
    public int maxSubArray(int[] nums) {
        nums[0] = 0 + nums[0];
        int max = nums[0];
        for(int i = 1; i < nums.length; i++){
            if(nums[i-1] > 0)
                nums[i] = nums[i] + nums[i-1];
            else
                nums[i] = nums[i];
            if(nums[i] > max)
                max = nums[i];
        }
        return max;
    }
}

