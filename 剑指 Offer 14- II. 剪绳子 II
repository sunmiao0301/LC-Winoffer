//第一版 通过 但是复杂度都不好 这一版需要注意两个地方
1） 
    需要推导取模与乘法之间的关系
    简单试了几个 好像和加法是一致的（加法在剑指offer斐波那契数列题中出现）
    也就是说：
    a = b * c
    则有
    a % 1000000007 = (b % 1000000007 * c % 1000000007) % 1000000007
2）
    long[] dp = new long[n + 1];//0 ~ n
    为什么是long 因为我发现如果是int 由于我写的关系式是：
    dp[i] = (3 * (dp[i - 3] % 1000000007)) % 1000000007;
    而int的范围是 -2147483648 ~ 2147483647
    所以当这个数字是一个接近于 1000000007 的数字时
    乘以 3 会导致大于 int 的范围继而出错
    所以用long
    由此也能看出改进方案就是 每次少乘一点？
    
执行结果：
通过
执行用时：
1 ms
, 在所有 Java 提交中击败了
9.41%
的用户
内存消耗：
35.4 MB
, 在所有 Java 提交中击败了
18.03%
的用户
class Solution {
    public int cuttingRope(int n) {
    /*
    需要推导取模与乘法之间的关系
    简单试了几个 好像和加法是一致的
    也就是说：
    a = b * c
    则有
    a % 1000000007 = (b % 1000000007 * c % 1000000007) % 1000000007
    
    题目如此一改
    好像只能通过动态规划解决而不能用递归了 
    因为递归是最后才得到结果
    不过如果从小到大递归好像可以
    尝试如下：

    */
    if(n == 2 || n == 3)return n - 1;
    long[] dp = new long[n + 1];//0 ~ n
    dp[2] = 2;
    dp[3] = 3;
    dp[4] = 4;
    for(int i = 5; i <= n; i++){
        dp[i] = (3 * (dp[i - 3] % 1000000007)) % 1000000007;
    }
    return (int)dp[n];
    }
}

//第二版
