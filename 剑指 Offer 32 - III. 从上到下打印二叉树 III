//第一版 考虑到其与剑指 Offer 32 - II 的差别只在于将偶数层的节点值输出顺序翻过来 所以自然而然的就想到用stack来实现
通过 但是效果不好
执行结果：
通过
执行用时：
3 ms
, 在所有 Java 提交中击败了
29.09%
的用户
内存消耗：
38.8 MB
, 在所有 Java 提交中击败了
13.87%
的用户
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    int depth = 1;
    public List<List<Integer>> levelOrder(TreeNode root) {
    /*
    建立一个栈对奇数行进行单独处理
    如果不用栈但是用for的情况 前面被处理的节点导致向队列中添加新的节点 会不会对i产生影响 （我觉得应该会 所以还是用栈）
    */
    List<List<Integer>> ret = new LinkedList<>();
    if(root == null)return ret;
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    Stack<Integer> stack = new Stack<>();//注意 存的是TreeNode.val
    while(!queue.isEmpty()){
        List<Integer> temp = new ArrayList<>();
        if(depth % 2 == 1){//奇数行 正常
            for(int i = queue.size(); i > 0; i--){
                if(queue.peek().left != null)queue.offer(queue.peek().left);
                if(queue.peek().right != null)queue.offer(queue.peek().right);
                temp.add(queue.poll().val);//ArrayList是add还是offer    
            }
            ret.add(temp);
            depth++;
        }
        else{
            for(int i = queue.size(); i > 0; i--){
                if(queue.peek().left != null)queue.offer(queue.peek().left);
                if(queue.peek().right != null)queue.offer(queue.peek().right);
                stack.push(queue.poll().val);
            }
            while(!stack.isEmpty()){
                temp.add(stack.pop());//ArrayList是add还是offer    
            }
            ret.add(temp);
            depth++;
            }
        }
        return ret;
    }
}

//第二版
