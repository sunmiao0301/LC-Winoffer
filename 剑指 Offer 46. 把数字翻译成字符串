··················本题既可以用动态规划 也可以用递归························
//第一版 自己套用递归回溯模板写的 可惜卡在了第36个样例
36 / 49 个通过测试用例
状态：解答错误
提交时间：几秒前
最后执行的输入：
506
执行结果：
解答错误
输入：
506
输出：
2
预期结果：
1
原因是05被判断为不能“翻译”成字母 所以得加个条件。
修改后见第二版

class Solution {
    int ret = 0;
    public int translateNum(int num) {
    //这题看似与字母相关，其实好像只需要判断当前的一位数或是两位数是否是在0 ~ 25 之间
    //先试试用递归回溯
    String s = "" + num;
    helper(0, s);
    return ret;
    }
    void helper(int index, String s){
        if(index == s.length()){
            ret++;
            return;
        }
        for(int i = 1; i < 3; i++){
            if(index + i <= s.length() && Integer.parseInt(s.substring(index, index + i)) >= 0 && Integer.parseInt(s.substring(index, index + i)) <= 25){//后面的两个是为i == 2准备的
                index += i;
                helper(index, s);
                index -= i;
            }
        }
        
    }
}

第二版
执行结果：
通过
执行用时：
5 ms
, 在所有 Java 提交中击败了
9.93%
的用户
内存消耗：
35.3 MB
, 在所有 Java 提交中击败了
29.50%
的用户
class Solution {
    int ret = 0;
    public int translateNum(int num) {
    //这题看似与字母相关，其实好像只需要判断当前的一位数或是两位数是否是在0 ~ 25 之间
    //先试试用递归回溯
    String s = "" + num;
    helper(0, s);
    return ret;
    }
    void helper(int index, String s){
        if(index == s.length()){
            ret++;
            return;
        }
        for(int i = 1; i < 3; i++){
            if(index + i <= s.length()){//后面的两个是为i == 2准备的
                if(i == 1){
                    index += i;
                    helper(index, s);
                    index -= i;
                }
                if(i == 2 && Integer.parseInt(s.substring(index, index + i)) >= 10 && Integer.parseInt(s.substring(index, index + i)) <= 25){
                    index += i;
                    helper(index, s);
                    index -= i;
                }
                
            }
        }
        
    }
}

ps 递归回溯模板
https://blog.csdn.net/abcdef314159/article/details/108583980
private void backtrack("原始参数") {
    //终止条件(递归必须要有终止条件)
    if ("终止条件") {
        //一些逻辑操作（可有可无，视情况而定）
        return;
    }

    for (int i = "for循环开始的参数"; i < "for循环结束的参数"; i++) {
        //一些逻辑操作（可有可无，视情况而定）

        //做出选择

        //递归
        backtrack("新的参数");
        //一些逻辑操作（可有可无，视情况而定）

        //撤销选择
    }
}

//第三版 动态规划
