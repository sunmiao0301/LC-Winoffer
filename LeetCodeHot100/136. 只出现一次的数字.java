####
解法一：暴力查找
两次循环，代码略

解法二：排序
使用快排，复杂度 O(nlogn)O(nlogn)

解法三：
利用 Hash 表，Time: O(n) Space: O(n)

########
使用hashset集合存储数组中出现的所有数字一次，并计算之和。
由于数组中只有一个元素出现一次，其余元素都出现两次
因此用集合中的元素之和的两倍减去数组中的元素之和，剩下的数就是数组中只出现一次的数字。
需要额外使用 O(n) 的空间，其中 n 是数组长度。

########
数组中的全部元素的异或运算结果即为数组中只出现一次的数字。
1、任何数和 0 做异或运算，结果仍然是原来的数
2、任何数和其自身做异或运算，结果是 0
3、异或运算满足交换律和结合律

执行结果：
通过
执行用时：
1 ms
, 在所有 Java 提交中击败了
100.00%
的用户
内存消耗：
38.4 MB
, 在所有 Java 提交中击败了
81.34%
的用户
通过测试用例：
61 / 61

class Solution {
    public int singleNumber(int[] nums) {
        int len = nums.length;
        int ret = 0;
        for(int i = 0; i < len; i++){
            ret = ret ^ nums[i];
        }
        return ret;
    }
}

时间复杂度：O(n)，其中 n 是数组长度。只需要对数组遍历一次。
空间复杂度：O(1)。
