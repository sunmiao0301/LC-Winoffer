2rd 效率一般
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        /** 
        我的思路是维护一个数组Deque 
        如果大于target 就把前面的删除 
        一旦小于 就在后面再加 直到再次大于 
        并且维护一个Deque总长的min值
        */
        Deque<Integer> d = new LinkedList<>();
        int res = Integer.MAX_VALUE;
        int dequeLen = 0;
        int sum = 0;
        int len = nums.length;
        for(int i = 0; i < len; i++){
            d.offerLast(nums[i]);
            sum += nums[i];
            dequeLen++;
            while(sum >= target){
                if(dequeLen < res)
                    res = dequeLen;
                sum -= d.pollFirst();
                dequeLen--;
            }
        }
        if(res == Integer.MAX_VALUE)
            return 0;
        return res;
    }
}

2rd 最佳方法的思路是一致的 区别在于将双端队列Deque替换成了双指针
class Solution {
    public int minSubArrayLen(int s, int[] nums) {
        int n = nums.length;
        if (n == 0) {
            return 0;
        }
        int ans = Integer.MAX_VALUE;
        int start = 0, end = 0;
        int sum = 0;
        while (end < n) {
            sum += nums[end];
            while (sum >= s) {
                ans = Math.min(ans, end - start + 1);
                sum -= nums[start];
                start++;
            }
            end++;
        }
        return ans == Integer.MAX_VALUE ? 0 : ans;
    }
}
复杂度分析
时间复杂度：O(n)，其中 n 是数组的长度。指针 start 和 end 最多各移动 n 次。
空间复杂度：O(1)。

//第一版 写到深夜 效率一般
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
    /*
    长度最小的
    滑动窗口还是不熟练
    我好像想到只遍历一遍的方法了
    之前剑指offer中提到过滑动窗口实际上是等价于双端队列的
    */
    if(nums[0] >= target)return 1;
    Deque<Integer> Deque = new LinkedList<>();
    int sum = 0, i = 0;
    for(i = 0; i < nums.length; i++){
        Deque.addLast(nums[i]);
        sum += nums[i];
        if(sum >= target)
            break;
    }
    if(i == nums.length)//说明直到最后一个值 都不够target
        return 0;

    if(i == nums.length - 1){//说明最后一个值加上之后大于等于target
        while(!Deque.isEmpty() && sum >= target){
            sum -= Deque.pollFirst();
        }
        return Deque.size() + 1;
    }
    int min = Deque.size();
    while(i < nums.length - 1 && !Deque.isEmpty()){
        if(sum >= target){
            sum -= Deque.pollFirst();
            if(Deque.size() < min && sum >= target)
                min = Deque.size();
            //min = (Deque.size() < min && sum >= target) ? Deque.size() : min;
            continue;
        }
        else{
            sum -= Deque.pollFirst();
            //min = (Deque.size() < min && sum >= target) ? Deque.size() : min;
            i++;
            Deque.addLast(nums[i]);
            sum += nums[i];
            
            if(Deque.size() < min && sum >= target)
                min = Deque.size();
            //min = (Deque.size() < min && sum >= target) ? Deque.size() : min;
            continue;
        }
    }
    if(Deque.isEmpty())
        return 1;
    return min;
    }
}
/*
213
[12,28,83,4,25,26,25,2,25,25,25,12]
80
[10,5,13,4,8,4,5,11,14,9...,16,10,20,8]
4
[1,4,4]
15
[1,2,3,4,5]
11
[1,2,3,4,5]
213
[12,28,83,4,25,26,25,2,25,25,25,12]
7
[2,3,1,2,4,3]
80
[10,5,13,4,8,4,5,11,14,9,16,10,20,8]
80
[11,14,9,16,10,20,8]
80
[4,5,11,14,9,16,10,20,8]
*/

//第二版 
就是想不要优化第一版速度的办法 
下面直接挂标准题解：
其实题解的思路与我的差别不大，关键在于
1）在更新min的时候 由于用的是双指针 所以节省了大量时间？把我用的Deque.size()修改成了双指针的hi - lo（没有用Deque）

············那么，是否滑动窗口问题都可以用双指针 而不必用 Deque 呢

class Solution {    
    public int minSubArrayLen(int target, int[] nums) {
        int lo = 0, hi = 0, sum = 0, min = Integer.MAX_VALUE;
        while (hi < nums.length) {
            sum += nums[hi++];
            while (sum >= target) {
                min = Math.min(min, hi - lo);
                sum -= nums[lo++];
            }
        }
        return min == Integer.MAX_VALUE ? 0 : min;
    }
}
