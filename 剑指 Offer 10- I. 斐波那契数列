//第一版 递归 方法对 但是会超时
24 / 51 个通过测试用例
状态：超出时间限制
提交时间：22 分钟前
最后执行的输入：
44

class Solution {
    public int fib(int n) {
        return helper(n) % 1000000007;
    }
    int helper(int n){
        if(n == 0)return 0;
        else if(n == 1)return 1;
        else return helper(n - 1) + helper(n - 2);
    }
}

//第二版 采取空间换时间的策略 （如果直接递归 会导致多次重复运算 用数组可以保证算过的不用再再算）
27 / 51 个通过测试用例
状态：解答错误
提交时间：11 小时前
最后执行的输入：
48
卡在48处
可能是超界了 换成long试试 见第三版

class Solution {
    public int fib(int n) {
        int[] arr = new int[n+1];
        helper(n, arr);
        return arr[n] % 1000000007;
    }
    void helper(int n, int[] arr){
        for(int i = 0; i < n+1; i++){
            if(i == 0) arr[i] = 0;
            else if(i == 1) arr[i] = 1;
            else arr[i] = arr[i-1] + arr[i-2];
        }
    }
}

//第三版 把第二版的int转换成long
47 / 51 个通过测试用例
执行结果：
解答错误
输入：
95
输出：
-757628988
预期结果：
407059028
我们可以试试更大的long long

class Solution {
    public int fib(int n) {
        long[] arr = new long[n+1];
        helper(n, arr);
        return (int)(arr[n] % 1000000007);
    }
    void helper(int n, long[] arr){
        for(int i = 0; i < n+1; i++){
            if(i == 0) arr[i] = 0;
            else if(i == 1) arr[i] = 1;
            else arr[i] = arr[i-1] + arr[i-2];
        }
    }
}

//第四版 long long数组不存在 所以换一种思路 如下：
    if a = b + c
    then a % 1000000007 = b % 1000000007 + c % 1000000007
    但是这不对
    举个范例
    a = 1000000007
    b = 1000000006
    c = 1
    那么
    a % 1000000007 = 0
    b % 1000000007 = 1000000006
    c % 1000000007 = 1
    也就是当 a 分割出的两个数 不是很大时
    就需要再对 b % 1000000007 + c % 1000000007 进行一次取模
    这控制了数组中的数始终保持在比较小的范围内 对时间效果好
    综上
    也就是
    if a = b + c
    then a % 1000000007 = (b % 1000000007 + c % 1000000007) % 1000000007
执行结果：
通过
显示详情
添加备注

执行用时：
0 ms
, 在所有 Java 提交中击败了
100.00%
的用户
内存消耗：
35.4 MB
, 在所有 Java 提交中击败了
9.98%
的用户
class Solution {
    public int fib(int n) {
        int[] arr = new int[n+1];
        helper(n, arr);
        return arr[n];
    }
    void helper(int n, int[] arr){
        for(int i = 0; i < n+1; i++){
            if(i == 0) arr[i] = 0;
            else if(i == 1) arr[i] = 1;
            else arr[i] = (arr[i-1] % 1000000007 + arr[i-2] % 1000000007) % 1000000007;
        }
    }
}

//第五版空间复杂度很差 想办法优化 其实从斐波那契的第三个数开始 就只与前两个数有关了 所以我们其实只需要存两个数即可 不需要建一个那么长的数组
